/* eslint-disable no-unused-vars */
export function getInputType(name) {
  const nameTypeMap = {
    LATENT: "LATENT",
    MODEL: "MODEL",
    CLIP: "CLIP",
    VAE: "VAE",
    CONDITIONING: "CONDITIONING",
    IMAGE: "IMAGE",
    MASK: "MASK",
    CLIP_VISION_OUTPUT: "CLIP_VISION_OUTPUT",
    positive: "CONDITIONING",
    negative: "CONDITIONING",
    CONTROL_NET: "CONTROL_NET",
    STYLE_MODEL: "STYLE_MODEL",
    CLIP_VISION: "CLIP_VISION",
    GLIGEN: "GLIGEN",
    latent: "LATENT",
    UPSCALE_MODEL: "UPSCALE_MODEL",
    output: "LATENT",
    denoised_output: "LATENT",
    SIGMAS: "SIGMAS",
    SAMPLER: "SAMPLER",
    high_sigmas: "SIGMAS",
    low_sigmas: "SIGMAS",
    GUIDER: "GUIDER",
    NOISE: "NOISE",
    PHOTOMAKER: "PHOTOMAKER",
    stage_c: "LATENT",
    stage_b: "LATENT",
    controlnet_input: "IMAGE",
    STRING: "STRING",
    "*": "*",
    INT: "INT",
    FLOAT: "FLOAT",
    BLIP_MODEL: "BLIP_MODEL",
    bus: "BUS",
    model: "MODEL",
    clip: "CLIP",
    vae: "VAE",
    latent_filename: "STRING",
    latent_image: "LATENT",
    image_filename: "STRING",
    conditioning_filename: "STRING",
    NAME_STRING: "STRING",
    conditioning: "CONDITIONING",
    parsed_text: "STRING",
    raw_text: "STRING",
    NUMBER: "NUMBER",
    image_a_pass: "IMAGE",
    image_b_pass: "IMAGE",
    filepath_text: "STRING",
    filename_text: "STRING",
    MASK_IMAGE: "IMAGE",
    clipseg_model: "CLIPSEG_MODEL",
    IMAGES_BATCH: "IMAGE",
    MASKS_BATCH: "MASK",
    MASK_IMAGES_BATCH: "IMAGE",
    IMAGES: "IMAGE",
    DICT: "DICT",
    BOOLEAN: "BOOLEAN",
    composited_images: "IMAGE",
    ssao_images: "IMAGE",
    specular_mask_images: "IMAGE",
    ssdo_images: "IMAGE",
    ssdo_image_masks: "IMAGE",
    light_source_image_masks: "IMAGE",
    aspect_number: "NUMBER",
    aspect_float: "FLOAT",
    is_landscape_bool: "NUMBER",
    aspect_ratio_common: "STRING",
    aspect_type: "STRING",
    image: "IMAGE",
    images: "IMAGE",
    color_palettes: "LIST",
    CROP_DATA: "CROP_DATA",
    mask: "MASK",
    shadow_map: "IMAGE",
    highlight_map: "IMAGE",
    width_num: "NUMBER",
    height_num: "NUMBER",
    width_float: "FLOAT",
    height_float: "FLOAT",
    width_int: "INT",
    height_int: "INT",
    MASKS: "MASK",
    INT_PLACES: "INT",
    "latent(s)": "LATENT",
    tensor_w_num: "NUMBER",
    tensor_h_num: "NUMBER",
    masks: "MASK",
    cropped_mask: "MASK",
    crop_data: "CROP_DATA",
    top_int: "INT",
    left_int: "INT",
    right_int: "INT",
    bottom_int: "INT",
    midas_model: "MIDAS_MODEL",
    number: "NUMBER",
    float: "FLOAT",
    int: "INT",
    SEED: "SEED",
    positive_string: "STRING",
    negative_string: "STRING",
    seed: "SEED",
    SAM_MODEL: "SAM_MODEL",
    SAM_PARAMETERS: "SAM_PARAMETERS",
    samples: "LATENT",
    IMAGE_BOUNDS: "IMAGE_BOUNDS",
    LIST: "LIST",
    TEXT_A_PASS: "STRING",
    TEXT_B_PASS: "STRING",
    SCORE_NUMBER: "NUMBER",
    COMPARISON_TEXT: "STRING",
    result_text: "STRING",
    replacement_count_number: "NUMBER",
    replacement_count_float: "FLOAT",
    replacement_count_int: "INT",
    f: "B",
    o: "O",
    u: "O",
    n: "L",
    d: "E",
    line_text: "STRING",
    dictionary: "DICT",
    MODEL_NAME_TEXT: "STRING",
    image_pass: "IMAGE",
    IMAGE_PASS: "IMAGE",
    output_path: "STRING",
    processed_count: "NUMBER",
    BBOX_DETECTOR: "BBOX_DETECTOR",
    SEGS: "SEGS",
    cropped: "IMAGE",
    cropped_refined: "IMAGE",
    cropped_refined_alpha: "IMAGE",
    cnet_images: "IMAGE",
    segs: "SEGS",
    basic_pipe: "BASIC_PIPE",
    combined_mask: "MASK",
    batch_masks: "MASK",
    cropped_enhanced_alpha: "IMAGE",
    detailer_pipe: "DETAILER_PIPE",
    refiner_basic_pipe_opt: "BASIC_PIPE",
    bbox_detector: "BBOX_DETECTOR",
    sam_model_opt: "SAM_MODEL",
    segm_detector_opt: "SEGM_DETECTOR",
    detailer_hook: "DETAILER_HOOK",
    refiner_model: "MODEL",
    refiner_clip: "CLIP",
    refiner_positive: "CONDITIONING",
    refiner_negative: "CONDITIONING",
    base_basic_pipe: "BASIC_PIPE",
    refiner_basic_pipe: "BASIC_PIPE",
    UPSCALER: "UPSCALER",
    PK_HOOK: "PK_HOOK",
    DETAILER_HOOK: "DETAILER_HOOK",
    UPSCALER_HOOK: "UPSCALER_HOOK",
    SEGS_HEADER: "SEGS_HEADER",
    SEG_ELT: "SEG_ELT",
    seg_elt: "SEG_ELT",
    cropped_image: "IMAGE",
    crop_region: "SEG_ELT_crop_region",
    bbox: "SEG_ELT_bbox",
    control_net_wrapper: "SEG_ELT_control_net_wrapper",
    confidence: "FLOAT",
    label: "STRING",
    left: "INT",
    top: "INT",
    right: "INT",
    bottom: "INT",
    KSAMPLER: "KSAMPLER",
    KSAMPLER_ADVANCED: "KSAMPLER_ADVANCED",
    selected_value: "*",
    selected_label: "STRING",
    selected_index: "INT",
    output1: "*",
    populated_text: "STRING",
    BASIC_PIPE: "BASIC_PIPE",
    REGIONAL_PROMPTS: "REGIONAL_PROMPTS",
    filtered_SEGS: "SEGS",
    remained_SEGS: "SEGS",
    signal_opt: "*",
    bool: "BOOLEAN",
    signal: "*",
    batch: "INT",
    height: "INT",
    width: "INT",
    channel: "INT",
    wildcard: "STRING",
    segs_labels: "STRING",
    count: "INT",
    total: "INT",
    value: "*",
    TRANSFORMERS_CLASSIFIER: "TRANSFORMERS_CLASSIFIER",
    scheduler: [
      "normal",
      "karras",
      "exponential",
      "sgm_uniform",
      "simple",
      "ddim_uniform",
    ],
    SEGM_DETECTOR: "SEGM_DETECTOR",
    TIMESTEP_KF: "TIMESTEP_KEYFRAME",
    LATENT_KF: "LATENT_KEYFRAME",
    model_opt: "MODEL",
    CN_WEIGHTS: "CONTROL_NET_WEIGHTS",
    TK_SHORTCUT: "TIMESTEP_KEYFRAME",
    proc_IMAGE: "IMAGE",
    SPARSE_METHOD: "SPARSE_METHOD",
    cn_extras: "CN_WEIGHTS_EXTRAS",
    "ABG_CHARACTER_MASK (MASK)": "MASK",
    POSE_KEYPOINT: "POSE_KEYPOINT",
    tracking: "TRACKING",
    prompt: "STRING",
    OPTICAL_FLOW: "OPTICAL_FLOW",
    PREVIEW_IMAGE: "IMAGE",
    INPAINTING_MASK: "MASK",
    preprocessor: [
      "none",
      "TilePreprocessor",
      "TTPlanet_TileGF_Preprocessor",
      "TTPlanet_TileSimple_Preprocessor",
      "AnimeFace_SemSegPreprocessor",
      "BinaryPreprocessor",
      "Zoe-DepthMapPreprocessor",
      "ColorPreprocessor",
      "DepthAnythingPreprocessor",
      "Zoe_DepthAnythingPreprocessor",
      "DensePosePreprocessor",
      "OneFormer-COCO-SemSegPreprocessor",
      "OneFormer-ADE20K-SemSegPreprocessor",
      "M-LSDPreprocessor",
      "AnyLineArtPreprocessor_aux",
      "DWPreprocessor",
      "AnimalPosePreprocessor",
      "DSINE-NormalMapPreprocessor",
      "MediaPipe-FaceMeshPreprocessor",
      "LineArtPreprocessor",
      "MiDaS-NormalMapPreprocessor",
      "MiDaS-DepthMapPreprocessor",
      "CannyEdgePreprocessor",
      "ShufflePreprocessor",
      "Metric3D-DepthMapPreprocessor",
      "Metric3D-NormalMapPreprocessor",
      "AnimeLineArtPreprocessor",
      "SAMPreprocessor",
      "HEDPreprocessor",
      "FakeScribblePreprocessor",
      "ScribblePreprocessor",
      "Scribble_XDoG_Preprocessor",
      "Scribble_PiDiNet_Preprocessor",
      "DiffusionEdge_Preprocessor",
      "SavePoseKpsAsJsonFile",
      "FacialPartColoringFromPoseKps",
      "UpperBodyTrackingFromPoseKps",
      "PiDiNetPreprocessor",
      "OpenposePreprocessor",
      "LeReS-DepthMapPreprocessor",
      "Unimatch_OptFlowPreprocessor",
      "MaskOptFlow",
      "ImageLuminanceDetector",
      "ImageIntensityDetector",
      "UniFormer-SemSegPreprocessor",
      "SemSegPreprocessor",
      "MeshGraphormer-DepthMapPreprocessor",
      "MeshGraphormer+ImpactDetector-DepthMapPreprocessor",
      "Manga2Anime_LineArt_Preprocessor",
      "BAE-NormalMapPreprocessor",
      "TEEDPreprocessor",
      "LineartStandardPreprocessor",
    ],
    "RESOLUTION (INT)": "INT",
    "IMAGE_GEN_WIDTH (INT)": "INT",
    "IMAGE_GEN_HEIGHT (INT)": "INT",
    "Full prompt": "STRING",
    "Short prompt": "STRING",
    "Compiled prompt": "CONDITIONING",
    Value: "STRING",
    Value2: "STRING",
    mix: "INT",
    Filenames: "VHS_FILENAMES",
    frame_count: "INT",
    audio: "VHS_AUDIO",
    video_info: "VHS_VIDEOINFO",
    meta_batch: "VHS_BatchManager",
    "source_fpsðŸŸ¨": "FLOAT",
    "source_frame_countðŸŸ¨": "INT",
    "source_durationðŸŸ¨": "FLOAT",
    "source_widthðŸŸ¨": "INT",
    "source_heightðŸŸ¨": "INT",
    "loaded_fpsðŸŸ¦": "FLOAT",
    "loaded_frame_countðŸŸ¦": "INT",
    "loaded_durationðŸŸ¦": "FLOAT",
    "loaded_widthðŸŸ¦": "INT",
    "loaded_heightðŸŸ¦": "INT",
    "fpsðŸŸ¨": "FLOAT",
    "frame_countðŸŸ¨": "INT",
    "durationðŸŸ¨": "FLOAT",
    "widthðŸŸ¨": "INT",
    "heightðŸŸ¨": "INT",
    "fpsðŸŸ¦": "FLOAT",
    "frame_countðŸŸ¦": "INT",
    "durationðŸŸ¦": "FLOAT",
    "widthðŸŸ¦": "INT",
    "heightðŸŸ¦": "INT",
    LATENT_A: "LATENT",
    A_count: "INT",
    LATENT_B: "LATENT",
    B_count: "INT",
    IMAGE_A: "IMAGE",
    IMAGE_B: "IMAGE",
    MASK_A: "MASK",
    MASK_B: "MASK",
    modelname: "STRING",
    sampler_name: [
      "euler",
      "euler_ancestral",
      "heun",
      "heunpp2",
      "dpm_2",
      "dpm_2_ancestral",
      "lms",
      "dpm_fast",
      "dpm_adaptive",
      "dpmpp_2s_ancestral",
      "dpmpp_sde",
      "dpmpp_sde_gpu",
      "dpmpp_2m",
      "dpmpp_2m_sde",
      "dpmpp_2m_sde_gpu",
      "dpmpp_3m_sde",
      "dpmpp_3m_sde_gpu",
      "ddpm",
      "lcm",
      "ddim",
      "uni_pc",
      "uni_pc_bh2",
    ],
    scheduler_name: "STRING",
    s: "STRING",
    x: "INT",
    y: "INT",
    REMBG_SESSION: "REMBG_SESSION",
    red: "MASK",
    green: "MASK",
    blue: "MASK",
    cyan: "MASK",
    magenta: "MASK",
    yellow: "MASK",
    black: "MASK",
    white: "MASK",
    CLIP_SEG: "CLIP_SEG",
    description: "STRING",
    response: "STRING",
    context: "STRING",
  };

  const matchName = nameTypeMap[name];
  if (matchName) {
    return matchName;
  } else {
    console.log("not matching name, will return unknown: ", name);
    return "XXX UNKNOWN INPUT TYPE XXX";
  }
}

// originally was in in file that imported app
function scanNodeInputOutput() {
  const nameTypeMap = new Map();

  function updateNameTypeMap(input, output) {
    const maxLength = Math.min(input.length, output.length);

    for (let i = 0; i < maxLength; i++) {
      const inputName = input[i];
      const outputName = output[i];

      // Add to nameTypeMap if inputName is not already present
      if (!nameTypeMap.has(inputName)) {
        nameTypeMap[inputName] = outputName;
      }
    }
  }


  console.log(LiteGraph.registered_node_types);
  if (LiteGraph.registered_node_types) {
    // Get the first node in the list
    for (const [key, nodeType] of Object.entries(
      LiteGraph.registered_node_types
    )) {
      console.log(key);
      if (nodeType.nodeData?.output !== undefined) {
        updateNameTypeMap(
          nodeType.nodeData.output_name,
          nodeType.nodeData.output
        );
      }
    }
    console.log(JSON.stringify(nameTypeMap));
  } else {
    console.log("No registered nodes found.");
  }
  return nameTypeMap;
}
